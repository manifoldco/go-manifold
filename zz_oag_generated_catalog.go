package manifold

import (
	context "context"
	fmt "fmt"
	http "net/http"
	url "net/url"
)

// This file is automatically generated by oag (https://github.com/jbowes/oag)
// DO NOT EDIT

// CreatePlan is a data type for API communication.
type CreatePlan struct {
	Body PlanBody `json:"body"`
}

// CreateProduct is a data type for API communication.
type CreateProduct struct {
	Body ProductBody `json:"body"`
}

// CreateProvider is a data type for API communication.
type CreateProvider struct {
	Body ProviderBody `json:"body"`
}

// CreateRegion is a data type for API communication.
type CreateRegion struct {
	Body RegionBody `json:"body"`
}

// FeatureType is a data type for API communication.
// A feature type represents the different aspects of a product that are
// offered, these features can manifest differently depending on the plan.
type FeatureType struct {
	Label string `json:"label"`
	Name  string `json:"name"`
	Type  string `json:"type"`
}

// FeatureValue is a data type for API communication.
type FeatureValue struct {
	Feature string `json:"feature"`
	Value   string `json:"value"`
}

// Plan is a data type for API communication.
type Plan struct {
	ID      ID       `json:"id"`
	Version int      `json:"version"`
	Type    string   `json:"type"`
	Body    PlanBody `json:"body"`
}

// PlanBody is a data type for API communication.
type PlanBody struct {
	ProviderID ID             `json:"provider_id"`
	ProductID  ID             `json:"product_id"`
	Name       string         `json:"name"`
	Label      string         `json:"label"`
	State      string         `json:"state"`
	Regions    []ID           `json:"regions"`  // Array of Region IDs
	Features   []FeatureValue `json:"features"` // Array of Feature Values

	// The number of days a user gets as a free trial when subscribing to
	// this plan. Trials are valid only once per product; changing plans
	// or adding an additional subscription will not start a new trial.
	TrialDays *int `json:"trial_days"`
	Cost      int  `json:"cost"` // Dollar value in cents
}

// PlansListOpts holds optional argument values
type PlansListOpts struct {
	Label *string `json:"label"` // Filter results to only include those that have this label.
}

// Product is a data type for API communication.
type Product struct {
	ID      ID          `json:"id"`
	Version int         `json:"version"`
	Type    string      `json:"type"`
	Body    ProductBody `json:"body"`
}

// ProductBody is a data type for API communication.
type ProductBody struct {
	ProviderID       ID          `json:"provider_id"`
	Label            string      `json:"label"`
	Name             string      `json:"name"`
	State            string      `json:"state"`
	LogoURL          string      `json:"logo_url"`
	Tagline          string      `json:"tagline"`     // 140 character sentence positioning the product.
	ValueProps       []ValueProp `json:"value_props"` // A list of value propositions of the product.
	Images           []string    `json:"images"`
	SupportEmail     string      `json:"support_email"`
	DocumentationURL string      `json:"documentation_url"`

	// URL to this Product's Terms of Service. If provided is true, then
	// a url must be set. Otherwise, provided is false.
	Terms        ProductBodyTerms       `json:"terms"`
	FeatureTypes []FeatureType          `json:"feature_types"`
	Billing      ProductBodyBilling     `json:"billing"`
	Integration  ProductBodyIntegration `json:"integration"`
}

// ProductBodyBilling is a data type for API communication.
type ProductBodyBilling struct {
	Type     string `json:"type"`
	Currency string `json:"currency"`
}

// ProductBodyIntegration is a data type for API communication.
type ProductBodyIntegration struct {
	BaseURL  string                         `json:"base_url"`
	SSOURL   string                         `json:"sso_url"`
	Version  string                         `json:"version"`
	Features ProductBodyIntegrationFeatures `json:"features"`
}

// ProductBodyIntegrationFeatures is a data type for API communication.
type ProductBodyIntegrationFeatures struct {
	SSO bool `json:"sso"` // Represents whether or not this product supports Single Sign On

	// Represents whether or not this product supports changing
	// the plan of a resource.
	PlanChange *bool `json:"plan_change"`

	// Describes how the region for a resource is specified, if
	// unspecified, then regions have no impact on this
	// resource.
	Region *string `json:"region"`
}

// ProductBodyTerms is a data type for API communication.
type ProductBodyTerms struct {
	URL      string `json:"url"`
	Provided bool   `json:"provided"`
}

// ProductsListOpts holds optional argument values
type ProductsListOpts struct {
	// Base32 encoded 18 byte identifier of the provider that these
	// products must belong to.
	ProviderID *ID     `json:"provider_id"`
	Label      *string `json:"label"` // Filter results to only include those that have this label.
}

// Provider is a data type for API communication.
type Provider struct {
	ID      ID           `json:"id"`
	Version int          `json:"version"`
	Type    string       `json:"type"`
	Body    ProviderBody `json:"body"`
}

// ProviderBody is a data type for API communication.
type ProviderBody struct {
	TeamID           ID      `json:"team_id"`
	Label            string  `json:"label"`
	Name             string  `json:"name"`
	LogoURL          *string `json:"logo_url"`          // Optional
	SupportEmail     *string `json:"support_email"`     // Optional
	DocumentationURL *string `json:"documentation_url"` // Optional
}

// ProvidersListOpts holds optional argument values
type ProvidersListOpts struct {
	Label *string `json:"label"` // Filter results to only include those that have this label.
}

// Region is a data type for API communication.
type Region struct {
	ID      ID         `json:"id"`
	Type    string     `json:"type"`
	Version int        `json:"version"`
	Body    RegionBody `json:"body"`
}

// RegionBody is a data type for API communication.
type RegionBody struct {
	Platform string  `json:"platform"`
	Location string  `json:"location"`
	Name     string  `json:"name"`
	Priority float64 `json:"priority"`
}

// RegionsListOpts holds optional argument values
type RegionsListOpts struct {
	Location *string `json:"location"` // Filter results to only include the regions that have this location.
	Platform *string `json:"platform"` // Filter results to only include the regions that are on this platform.
}

// ValueProp is a data type for API communication.
type ValueProp struct {
	Header string `json:"header"` // Heading of a value proposition.
	Body   string `json:"body"`   // Body of a value proposition.
}

// PlanIter Iterates over a result set of Plans.
type PlanIter struct {
	page []Plan
	i    int

	err   error
	first bool
}

// Close closes the PlanIter and releases any associated resources.
// After Close, any calls to Current will return an error.
func (i *PlanIter) Close() {}

// Next advances the PlanIter and returns a boolean indicating if the end has been reached.
// Next must be called before the first call to Current.
// Calls to Current after Next returns false will return an error.
func (i *PlanIter) Next() bool {
	if i.first && i.err != nil {
		i.first = false
		return true
	}
	i.first = false
	i.i++
	return i.i < len(i.page)
}

// Current returns the current Plan, and an optional error. Once an error has been returned,
// the PlanIter is closed, or the end of iteration is reached, subsequent calls to Current
// will return an error.
func (i *PlanIter) Current() (*Plan, error) {
	if i.err != nil {
		return nil, i.err
	}
	return &i.page[i.i], nil
}

// ProductIter Iterates over a result set of Products.
type ProductIter struct {
	page []Product
	i    int

	err   error
	first bool
}

// Close closes the ProductIter and releases any associated resources.
// After Close, any calls to Current will return an error.
func (i *ProductIter) Close() {}

// Next advances the ProductIter and returns a boolean indicating if the end has been reached.
// Next must be called before the first call to Current.
// Calls to Current after Next returns false will return an error.
func (i *ProductIter) Next() bool {
	if i.first && i.err != nil {
		i.first = false
		return true
	}
	i.first = false
	i.i++
	return i.i < len(i.page)
}

// Current returns the current Product, and an optional error. Once an error has been returned,
// the ProductIter is closed, or the end of iteration is reached, subsequent calls to Current
// will return an error.
func (i *ProductIter) Current() (*Product, error) {
	if i.err != nil {
		return nil, i.err
	}
	return &i.page[i.i], nil
}

// ProviderIter Iterates over a result set of Providers.
type ProviderIter struct {
	page []Provider
	i    int

	err   error
	first bool
}

// Close closes the ProviderIter and releases any associated resources.
// After Close, any calls to Current will return an error.
func (i *ProviderIter) Close() {}

// Next advances the ProviderIter and returns a boolean indicating if the end has been reached.
// Next must be called before the first call to Current.
// Calls to Current after Next returns false will return an error.
func (i *ProviderIter) Next() bool {
	if i.first && i.err != nil {
		i.first = false
		return true
	}
	i.first = false
	i.i++
	return i.i < len(i.page)
}

// Current returns the current Provider, and an optional error. Once an error has been returned,
// the ProviderIter is closed, or the end of iteration is reached, subsequent calls to Current
// will return an error.
func (i *ProviderIter) Current() (*Provider, error) {
	if i.err != nil {
		return nil, i.err
	}
	return &i.page[i.i], nil
}

// RegionIter Iterates over a result set of Regions.
type RegionIter struct {
	page []Region
	i    int

	err   error
	first bool
}

// Close closes the RegionIter and releases any associated resources.
// After Close, any calls to Current will return an error.
func (i *RegionIter) Close() {}

// Next advances the RegionIter and returns a boolean indicating if the end has been reached.
// Next must be called before the first call to Current.
// Calls to Current after Next returns false will return an error.
func (i *RegionIter) Next() bool {
	if i.first && i.err != nil {
		i.first = false
		return true
	}
	i.first = false
	i.i++
	return i.i < len(i.page)
}

// Current returns the current Region, and an optional error. Once an error has been returned,
// the RegionIter is closed, or the end of iteration is reached, subsequent calls to Current
// will return an error.
func (i *RegionIter) Current() (*Region, error) {
	if i.err != nil {
		return nil, i.err
	}
	return &i.page[i.i], nil
}

// PlansClient provides access to the /plans APIs
type PlansClient endpoint

// Create corresponds to the POST /plans/ endpoint.
//
// Add a new plan
func (c *PlansClient) Create(ctx context.Context, createPlan *CreatePlan) (*Plan, error) {
	p := "/plans/"

	req, err := c.backend.NewRequest(http.MethodPost, p, nil, createPlan)
	if err != nil {
		return nil, err
	}

	var resp Plan
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 403, 409, 500:
			return &Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// Get corresponds to the GET /plans/:id endpoint.
//
// Get a plan by ID
func (c *PlansClient) Get(ctx context.Context, id ID) (*Plan, error) {
	idBytes, err := id.MarshalText()
	if err != nil {
		return nil, err
	}

	p := fmt.Sprintf("/plans/%s", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodGet, p, nil, nil)
	if err != nil {
		return nil, err
	}

	var resp Plan
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		return &Error{}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// List corresponds to the GET /plans/ endpoint.
//
// Get a list of plans.
func (c *PlansClient) List(ctx context.Context, productID []ID, opts *PlansListOpts) *PlanIter {
	iter := PlanIter{
		first: true,
		i:     -1,
	}

	p := "/plans/"

	q := make(url.Values)
	for _, v := range productID {
		b, err := v.MarshalText()
		if err != nil {
			return &iter
		}
		q.Add("product_id", string(b))
	}

	if opts != nil {

		if opts.Label != nil {
			q.Set("label", *opts.Label)
		}
	}

	var req *http.Request
	req, iter.err = c.backend.NewRequest(http.MethodGet, p, q, nil)
	if iter.err != nil {
		return &iter
	}

	_, iter.err = c.backend.Do(ctx, req, &iter.page, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &Error{}
		default:
			return nil
		}
	})
	return &iter
}

// ProductsClient provides access to the /products APIs
type ProductsClient endpoint

// Create corresponds to the POST /products/ endpoint.
//
// Add a new product
func (c *ProductsClient) Create(ctx context.Context, createProduct *CreateProduct) (*Product, error) {
	p := "/products/"

	req, err := c.backend.NewRequest(http.MethodPost, p, nil, createProduct)
	if err != nil {
		return nil, err
	}

	var resp Product
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 403, 409, 500:
			return &Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// Get corresponds to the GET /products/:id endpoint.
//
// Get a product by ID
func (c *ProductsClient) Get(ctx context.Context, id ID) (*Product, error) {
	idBytes, err := id.MarshalText()
	if err != nil {
		return nil, err
	}

	p := fmt.Sprintf("/products/%s", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodGet, p, nil, nil)
	if err != nil {
		return nil, err
	}

	var resp Product
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// List corresponds to the GET /products/ endpoint.
//
// List all available products
func (c *ProductsClient) List(ctx context.Context, opts *ProductsListOpts) *ProductIter {
	iter := ProductIter{
		first: true,
		i:     -1,
	}

	p := "/products/"

	var q url.Values
	if opts != nil {
		q = make(url.Values)
		if opts.ProviderID != nil {
			b, err := opts.ProviderID.MarshalText()
			if err != nil {
				return &iter
			}
			q.Set("provider_id", string(b))
		}

		if opts.Label != nil {
			q.Set("label", *opts.Label)
		}
	}

	var req *http.Request
	req, iter.err = c.backend.NewRequest(http.MethodGet, p, q, nil)
	if iter.err != nil {
		return &iter
	}

	_, iter.err = c.backend.Do(ctx, req, &iter.page, func(code int) error {
		switch code {
		case 400, 500:
			return &Error{}
		default:
			return nil
		}
	})
	return &iter
}

// ProvidersClient provides access to the /providers APIs
type ProvidersClient endpoint

// Create corresponds to the POST /providers/ endpoint.
//
// Add a new provider
func (c *ProvidersClient) Create(ctx context.Context, createProvider *CreateProvider) (*Provider, error) {
	p := "/providers/"

	req, err := c.backend.NewRequest(http.MethodPost, p, nil, createProvider)
	if err != nil {
		return nil, err
	}

	var resp Provider
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 403, 409, 500:
			return &Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// Get corresponds to the GET /providers/:id endpoint.
//
// Get a provider by ID
func (c *ProvidersClient) Get(ctx context.Context, id ID) (*Provider, error) {
	idBytes, err := id.MarshalText()
	if err != nil {
		return nil, err
	}

	p := fmt.Sprintf("/providers/%s", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodGet, p, nil, nil)
	if err != nil {
		return nil, err
	}

	var resp Provider
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 404, 500:
			return &Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// List corresponds to the GET /providers/ endpoint.
//
// List all available providers
func (c *ProvidersClient) List(ctx context.Context, opts *ProvidersListOpts) *ProviderIter {
	iter := ProviderIter{
		first: true,
		i:     -1,
	}

	p := "/providers/"

	var q url.Values
	if opts != nil {
		q = make(url.Values)
		if opts.Label != nil {
			q.Set("label", *opts.Label)
		}
	}

	var req *http.Request
	req, iter.err = c.backend.NewRequest(http.MethodGet, p, q, nil)
	if iter.err != nil {
		return &iter
	}

	_, iter.err = c.backend.Do(ctx, req, &iter.page, func(code int) error {
		if code == 500 {
			return &Error{}
		}
		return nil
	})
	return &iter
}

// RegionsClient provides access to the /regions APIs
type RegionsClient endpoint

// Create corresponds to the POST /regions/ endpoint.
//
// Add a new region
func (c *RegionsClient) Create(ctx context.Context, createRegion *CreateRegion) (*Region, error) {
	p := "/regions/"

	req, err := c.backend.NewRequest(http.MethodPost, p, nil, createRegion)
	if err != nil {
		return nil, err
	}

	var resp Region
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 409, 500:
			return &Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// Get corresponds to the GET /regions/:id endpoint.
//
// Get a Region by ID
func (c *RegionsClient) Get(ctx context.Context, id ID) (*Region, error) {
	idBytes, err := id.MarshalText()
	if err != nil {
		return nil, err
	}

	p := fmt.Sprintf("/regions/%s", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodGet, p, nil, nil)
	if err != nil {
		return nil, err
	}

	var resp Region
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// List corresponds to the GET /regions/ endpoint.
//
// List all available regions
func (c *RegionsClient) List(ctx context.Context, opts *RegionsListOpts) *RegionIter {
	iter := RegionIter{
		first: true,
		i:     -1,
	}

	p := "/regions/"

	var q url.Values
	if opts != nil {
		q = make(url.Values)
		if opts.Location != nil {
			q.Set("location", *opts.Location)
		}

		if opts.Platform != nil {
			q.Set("platform", *opts.Platform)
		}
	}

	var req *http.Request
	req, iter.err = c.backend.NewRequest(http.MethodGet, p, q, nil)
	if iter.err != nil {
		return &iter
	}

	_, iter.err = c.backend.Do(ctx, req, &iter.page, func(code int) error {
		if code == 500 {
			return &Error{}
		}
		return nil
	})
	return &iter
}

// CatalogClient is an API client for all endpoints.
type CatalogClient struct {
	common endpoint // Reuse a single struct instead of allocating one for each endpoint on the heap.

	Plans     *PlansClient
	Products  *ProductsClient
	Providers *ProvidersClient
	Regions   *RegionsClient
}

// NewCatalog returns a new CatalogClient with the default configuration.
func NewCatalog() *CatalogClient {
	c := &CatalogClient{}
	c.common.backend = DefaultBackend()

	c.Plans = (*PlansClient)(&c.common)
	c.Products = (*ProductsClient)(&c.common)
	c.Providers = (*ProvidersClient)(&c.common)
	c.Regions = (*RegionsClient)(&c.common)

	return c
}
