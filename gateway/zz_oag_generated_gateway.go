package gateway

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"

	gomanifold "github.com/manifoldco/go-manifold"
)

// This file is automatically generated by oag (https://github.com/jbowes/oag)
// DO NOT EDIT

// CatalogFeatureType is a data type for API communication.
// A feature type represents the different aspects of a product that are
// offered, these features can manifest differently depending on the plan.
type CatalogFeatureType struct {
	Label        string `json:"label"`
	Name         string `json:"name"`
	Type         string `json:"type"`
	Customizable *bool  `json:"customizable"` // This sets whether or not the feature can be customized by a consumer.

	// This sets whether or not the feature can be upgraded by the consumer after the
	// resource has provisioned. Upgrading means setting a higher value or selecting a
	// higher element in the list.
	Upgradable *bool `json:"upgradable"`

	// This sets whether or not the feature can be downgraded by the consumer after the
	// resource has provisioned. Downgrading means setting a lower value or selecting a
	// lower element in the list.
	Downgradable *bool `json:"downgradable"`

	// Sets if this feature’s value is trackable from the provider,
	// this only really affects numeric constraints.
	Measurable *bool                         `json:"measurable"`
	Values     *[]CatalogFeatureValueDetails `json:"values"` // Optional
}

// CatalogFeatureValueDetails is a data type for API communication.
type CatalogFeatureValueDetails struct {
	Label string `json:"label"`
	Name  string `json:"name"`

	// The cost that will be added to the monthly plan cost when this value
	// is selected or is default for the plan.
	// Cost is deprecated in favor of the `price.cost` field.
	Cost *int `json:"cost"`

	// Price describes the cost of a feature. It should be preferred over
	// the `cost` property.
	Price *struct {
		// Cost is the price in cents that will be added to plan's base cost
		// when this value is selected or is default for the plan.
		// Number features should use the cost range instead.
		Cost *int `json:"cost"`

		// When a feature is used to multiply the cost of the plan or of
		// another feature, multiply factor is used for calculation.
		// A feature cannot have both a cost and a multiply factor.
		MultiplyFactor *float64 `json:"multiply_factor"`
		Formula        *string  `json:"formula"`     // Optional
		Description    *string  `json:"description"` // Description explains how a feature is calculated to the user.
	} `json:"price"`

	NumericDetails *struct {
		// Sets the increment at which numbers can be selected if customizable, by
		// default this is 1; for example, setting this to 8 would only allow integers
		// in increments of 8 ( 0, 8, 16, ... ). This property is not used if the
		// feature is measurable; except if it is set to 0, setting the increment to 0
		// means this numeric details has no scale, and will not be or customizable.
		// Some plans may not have a measureable or customizable feature.
		Increment *int `json:"increment"`
		Min       *int `json:"min"` // Minimum value that can be set by a user if customizable
		Max       *int `json:"max"` // Maximum value that can be set by a user if customizable

		// Applied to the end of the number for display, for example the ‘GB’ in ‘20 GB’.
		Suffix *string `json:"suffix"`

		CostRanges *[]struct {
			// Defines the end of the range ( inclusive ), from the previous, or 0;
			// where the cost_multiple starts taking effect. If set to -1 this defines the
			// range to infinity, or the maximum integer the system can handle
			// ( whichever comes first ).
			Limit *int `json:"limit"`

			// An integer in 10,000,000ths of cents, will be multiplied by the
			// numeric value set in the feature to determine the cost.
			CostMultiple *int `json:"cost_multiple"`
		} `json:"cost_ranges"` // Optional
	} `json:"numeric_details"` // Optional
}

// GetMeOpts holds optional argument values
type GetMeOpts struct {
	ProductLabel *string `json:"product_label"` // Label of the Product to filter Resources by.
	ProjectLabel *string `json:"project_label"` // Label of the Project to filter Resources by.
}

// Owner is a data type for API communication.
type Owner struct {
	ID   gomanifold.ID `json:"id"`
	Type string        `json:"type"`
	Name *string       `json:"name"` // Optional
}

// PlanCostRequest is a data type for API communication.
type PlanCostRequest struct {
	Features map[string]interface{} `json:"features"`
}

// Price is a data type for API communication.
type Price struct {
	Cost     int    `json:"cost"`
	Currency string `json:"currency"`
}

// ProductsListOpts holds optional argument values
type ProductsListOpts struct {
	// Base32 encoded 18 byte identifier of the provider that these
	// products must belong to.
	ProviderID   *gomanifold.ID `json:"provider_id"`
	IncludePlans *bool          `json:"include_plans"` // Return product listings without plan information
}

// ResolvedPlan is a data type for API communication.
type ResolvedPlan struct {
	Name  string `json:"name"`
	Label string `json:"label"`
	State string `json:"state"`

	Features []struct {
		Feature string `json:"feature"`
		Value   string `json:"value"`
	} `json:"features"` // Array of Feature Values
	Cost int `json:"cost"` // Dollar value in cents.

	ExpandedFeatures []struct {
		CatalogFeatureType

		// The string value set for the feature on the plan, this should only be used if the value property is null.
		ValueString string                     `json:"value_string"`
		Value       CatalogFeatureValueDetails `json:"value"`
	} `json:"expanded_features"` // An array of feature definitions for the plan, as defined on the Product.

	// A boolean flag that indicates if a plan is free or not based on it's cost and features.
	Free         bool          `json:"free"`
	DefaultCost  *int          `json:"defaultCost"`  // Plan cost using its default features plus base cost.
	Customizable *bool         `json:"customizable"` // A boolean flag that indicates if a plan has customizable features.
	ID           gomanifold.ID `json:"id"`
}

// ResolvedProduct is a data type for API communication.
type ResolvedProduct struct {
	ProviderID gomanifold.ID `json:"provider_id"`
	Label      string        `json:"label"`
	Name       string        `json:"name"`
	State      string        `json:"state"`

	Listing struct {
		// When true, everyone can see the product when requested. When false it will
		// not be visible to anyone except those on the provider team.
		Public *bool `json:"public"`

		// When true, the product will be displayed in product listings alongside
		// other products. When false the product will be excluded from listings,
		// but can still be provisioned directly if it's label is known.
		// Any pages that display information about the product when not listed,
		// should indicate to webcrawlers that the content should not be indexed.
		Listed *bool `json:"listed"`

		// Object to hold various flags for marketing purposes only. These are values
		// that need to be stored, but should not affect decision making in code. If
		// we find ourselves in a position where we think they should, we should
		// consider refactoring our listing definition.
		Marketing *struct {
			// Indicates whether or not the product is in `Beta` and should be
			// advertised as such. This does not have any impact on who can access the
			// product, it is just used to inform consumers through our clients.
			Beta *bool `json:"beta"`

			// Indicates whether or not the product is in `New` and should be
			// advertised as such. This does not have any impact on who can access the
			// product, it is just used to inform consumers through our clients.
			New *bool `json:"new"`

			// Indicates whether or not the product is in `New` and should be
			// advertised as such. This does not have any impact on who can access the
			// product, it is just used to inform consumers through our clients.
			Featured *bool `json:"featured"`
		} `json:"marketing"`
	} `json:"listing"`

	// Logo used for Provider and Product listings.
	//
	// Must be square (same width and height) and minimum 400px. Maximum of 800px.
	LogoURL string `json:"logo_url"`
	Tagline string `json:"tagline"` // 140 character sentence positioning the product.

	ValueProps []struct {
		Header string `json:"header"` // Heading of a value proposition.
		Body   string `json:"body"`   // Body of a value proposition.
	} `json:"value_props"` // A list of value propositions of the product.
	Images           []string `json:"images"`
	SupportEmail     string   `json:"support_email"`
	DocumentationURL string   `json:"documentation_url"`

	// URL to this Product's Terms of Service. If provided is true, then
	// a url must be set. Otherwise, provided is false.
	Terms struct {
		URL      string `json:"url"`
		Provided bool   `json:"provided"`
	} `json:"terms"`
	FeatureTypes []CatalogFeatureType `json:"feature_types"`

	Billing struct {
		Type     string `json:"type"`
		Currency string `json:"currency"`
	} `json:"billing"`

	Integration struct {
		// Provider Only, implies that the product should only be provisionable by the
		//   provider; so members of the provider team, no one else should be allowed.
		// Pre-Order, should not be used yet. But in the future it should allow people to
		//   pre-provision a resource for when it does go live.
		// Public, means the resource is live and everyone should be able to provision it.
		Provisioning string  `json:"provisioning"`
		BaseURL      string  `json:"base_url"`
		SSOURL       *string `json:"sso_url"` // Optional
		Version      string  `json:"version"`

		Features struct {
			// Indicates whether or not this product supports resource transitions to
			// manifold by access_code.
			AccessCode *bool `json:"access_code"`
			SSO        *bool `json:"sso"` // Represents whether or not this product supports Single Sign On

			// Represents whether or not this product supports changing
			// the plan of a resource.
			PlanChange *bool `json:"plan_change"`

			// Describes how the region for a resource is specified, if
			// unspecified, then regions have no impact on this
			// resource.
			Region *string `json:"region"`
		} `json:"features"`
	} `json:"integration"`
	Tags *[]string     `json:"tags"` // List of tags for product categorization and search
	ID   gomanifold.ID `json:"id"`

	Provider *struct {
		ID    *gomanifold.ID `json:"id"`    // Optional
		Name  *string        `json:"name"`  // Optional
		Label *string        `json:"label"` // Optional
	} `json:"provider"` // Optional
	Plans *[]ResolvedPlan `json:"plans"` // Optional

	// An array of marketing labels for the product listing, generated from the product details.
	ListingLabels []string `json:"listing_labels"`
}

// Resource is a data type for API communication.
type Resource struct {
	ResourceBodyRequired
	ResourceBodyReadFeatures
	CreatedAt string          `json:"created_at"`
	UpdatedAt string          `json:"updated_at"`
	ID        gomanifold.ID   `json:"id"`
	Product   ResolvedProduct `json:"product"`
	Plan      ResolvedPlan    `json:"plan"`

	Region *struct {
		ID   *gomanifold.ID `json:"id"`   // Optional
		Name *string        `json:"name"` // Optional
	} `json:"region"` // Optional

	Project *struct {
		ID    *gomanifold.ID `json:"id"`    // Optional
		Name  *string        `json:"name"`  // Optional
		Label *string        `json:"label"` // Optional
	} `json:"project"` // Optional
	EstimatedCost *Price                  `json:"estimated_cost"` // Optional
	Metadata      *map[string]interface{} `json:"metadata"`       // Optional
	Annotations   *map[string]interface{} `json:"annotations"`    // Optional
}

// ResourceBodyRead is a data type for API communication.
type ResourceBodyRead struct {
	Type  string  `json:"type"`
	State *string `json:"state"` // Optional

	Operation *struct {
		Status  *string `json:"status"`  // Optional
		State   *string `json:"state"`   // Optional
		Message *string `json:"message"` // Optional
	} `json:"operation"` // Optional
}

// ResourceBodyReadFeatures is a data type for API communication.
type ResourceBodyReadFeatures struct {
	ResourceBodySource
	ResourceBodyRead

	Features []struct {
		Label    string `json:"label"`
		Name     string `json:"name"`
		Measured *bool  `json:"measured"` // Optional
		Type     string `json:"type"`

		Value struct {
			Value        *struct{} `json:"value"`        // Optional
			DisplayValue *string   `json:"displayValue"` // Optional

			// Applied to the end of the number for display, for example the ‘GB’ in ‘20 GB’.
			Suffix *string `json:"suffix"`

			Price *struct {
				Cost           *int    `json:"cost"` // Optional
				MultiplyFactor float64 `json:"multiply_factor"`
				Formula        string  `json:"formula"`
			} `json:"price"` // Optional
		} `json:"value"`
	} `json:"features"`
}

// ResourceBodyRequired is a data type for API communication.
type ResourceBodyRequired struct {
	Label string `json:"label"`
	Owner Owner  `json:"owner"`
}

// ResourceBodySource is a data type for API communication.
type ResourceBodySource struct {
	Source string `json:"source"`
}

// ResourceBodyWrite is a data type for API communication.
type ResourceBodyWrite struct {
	Label *string `json:"label"` // Optional
	Owner *Owner  `json:"owner"` // Optional
}

// ResourceCreateRequest is a data type for API communication.
type ResourceCreateRequest struct {
	ResourceBodyWrite
	ResourceBodySource
	ProductID   *gomanifold.ID          `json:"product_id"`  // Optional
	PlanID      *gomanifold.ID          `json:"plan_id"`     // Optional
	RegionID    *gomanifold.ID          `json:"region_id"`   // Optional
	ProjectID   *gomanifold.ID          `json:"project_id"`  // Optional
	Features    *map[string]interface{} `json:"features"`    // Optional
	Annotations *map[string]interface{} `json:"annotations"` // Optional
}

// ResourceUpdateRequest is a data type for API communication.
type ResourceUpdateRequest struct {
	ResourceBodyWrite
	PlanID      *gomanifold.ID          `json:"plan_id"`     // Optional
	ProjectID   *gomanifold.ID          `json:"project_id"`  // Optional
	Features    *map[string]interface{} `json:"features"`    // Optional
	Annotations *map[string]interface{} `json:"annotations"` // Optional
}

// ResourcesGetOpts holds optional argument values
type ResourcesGetOpts struct {
	ProductLabel *string `json:"product_label"` // Label of the Product to filter Resources by.
	ProjectLabel *string `json:"project_label"` // Label of the Project to filter Resources by.
}

// ResolvedProductIter Iterates over a result set of ResolvedProducts.
type ResolvedProductIter struct {
	page []ResolvedProduct
	i    int

	err   error
	first bool
}

// Close closes the ResolvedProductIter and releases any associated resources.
// After Close, any calls to Current will return an error.
func (i *ResolvedProductIter) Close() {}

// Next advances the ResolvedProductIter and returns a boolean indicating if the end has been reached.
// Next must be called before the first call to Current.
// Calls to Current after Next returns false will return an error.
func (i *ResolvedProductIter) Next() bool {
	if i.first && i.err != nil {
		i.first = false
		return true
	}
	i.first = false
	i.i++
	return i.i < len(i.page)
}

// Current returns the current ResolvedProduct, and an optional error. Once an error has been returned,
// the ResolvedProductIter is closed, or the end of iteration is reached, subsequent calls to Current
// will return an error.
func (i *ResolvedProductIter) Current() (*ResolvedProduct, error) {
	if i.err != nil {
		return nil, i.err
	}
	return &i.page[i.i], nil
}

// IDClient provides access to the /id APIs
type IDClient endpoint

// CreatePlanCost corresponds to the POST /id/plan/:id/cost endpoint.
//
// Get plan cost
// Get how much a plan would cost when using a set of features
func (c *IDClient) CreatePlanCost(ctx context.Context, id gomanifold.ID, planCostRequest *PlanCostRequest) (*Price, error) {
	idBytes, err := id.MarshalText()
	if err != nil {
		return nil, err
	}

	p := fmt.Sprintf("/id/plan/%s/cost", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodPost, p, nil, planCostRequest)
	if err != nil {
		return nil, err
	}

	var resp Price
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// DeleteResource corresponds to the DELETE /id/resource/:id endpoint.
//
// Delete an existing resource
// Deletes an existing resource
func (c *IDClient) DeleteResource(ctx context.Context, id gomanifold.ID) error {
	idBytes, err := id.MarshalText()
	if err != nil {
		return err
	}

	p := fmt.Sprintf("/id/resource/%s", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodDelete, p, nil, nil)
	if err != nil {
		return err
	}

	_, err = c.backend.Do(ctx, req, nil, func(code int) error {
		switch code {
		case 400, 401, 409, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return err
	}

	return nil
}

// GetProduct corresponds to the GET /id/product/:id endpoint.
//
// Get information about a product
// Get information about the specified product
func (c *IDClient) GetProduct(ctx context.Context, id gomanifold.ID) (*ResolvedProduct, error) {
	idBytes, err := id.MarshalText()
	if err != nil {
		return nil, err
	}

	p := fmt.Sprintf("/id/product/%s", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodGet, p, nil, nil)
	if err != nil {
		return nil, err
	}

	var resp ResolvedProduct
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// GetResource corresponds to the GET /id/resource/:id endpoint.
//
// Get information about a resource
// Get information about the resource and it's operational status
func (c *IDClient) GetResource(ctx context.Context, id gomanifold.ID) (*Resource, error) {
	idBytes, err := id.MarshalText()
	if err != nil {
		return nil, err
	}

	p := fmt.Sprintf("/id/resource/%s", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodGet, p, nil, nil)
	if err != nil {
		return nil, err
	}

	var resp Resource
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// UpdateResource corresponds to the PATCH /id/resource/:id endpoint.
//
// Update an existing resource
// Updates an existing resource
func (c *IDClient) UpdateResource(ctx context.Context, id gomanifold.ID, resourceUpdateRequest *ResourceUpdateRequest) (*Resource, error) {
	idBytes, err := id.MarshalText()
	if err != nil {
		return nil, err
	}

	p := fmt.Sprintf("/id/resource/%s", string(idBytes))

	req, err := c.backend.NewRequest(http.MethodPatch, p, nil, resourceUpdateRequest)
	if err != nil {
		return nil, err
	}

	var resp Resource
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 401, 409, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// ProductClient provides access to the /product APIs
type ProductClient endpoint

// Get corresponds to the GET /product/:label endpoint.
//
// Get information about a product
// Get information about the specified product
func (c *ProductClient) Get(ctx context.Context, label string) (*ResolvedProduct, error) {
	p := fmt.Sprintf("/product/%s", label)

	req, err := c.backend.NewRequest(http.MethodGet, p, nil, nil)
	if err != nil {
		return nil, err
	}

	var resp ResolvedProduct
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// ProductsClient provides access to the /products APIs
type ProductsClient endpoint

// List corresponds to the GET /products/ endpoint.
//
// List all available products
func (c *ProductsClient) List(ctx context.Context, opts *ProductsListOpts) *ResolvedProductIter {
	iter := ResolvedProductIter{
		first: true,
		i:     -1,
	}

	p := "/products/"

	var q url.Values
	if opts != nil {
		q = make(url.Values)
		if opts.ProviderID != nil {
			b, err := opts.ProviderID.MarshalText()
			if err != nil {
				return &iter
			}
			q.Set("provider_id", string(b))
		}

		if opts.IncludePlans != nil {
			q.Set("include_plans", strconv.FormatBool(*opts.IncludePlans))
		}
	}

	var req *http.Request
	req, iter.err = c.backend.NewRequest(http.MethodGet, p, q, nil)
	if iter.err != nil {
		return &iter
	}

	_, iter.err = c.backend.Do(ctx, req, &iter.page, func(code int) error {
		switch code {
		case 400, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	return &iter
}

// ResourceClient provides access to the /resource APIs
type ResourceClient endpoint

// Create corresponds to the POST /resource endpoint.
//
// Create a new Resource
// Create a new resource, and returns the details about it
func (c *ResourceClient) Create(ctx context.Context, resourceCreateRequest *ResourceCreateRequest) (*Resource, error) {
	p := "/resource"

	req, err := c.backend.NewRequest(http.MethodPost, p, nil, resourceCreateRequest)
	if err != nil {
		return nil, err
	}

	var resp Resource
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 401, 409, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// ResourcesClient provides access to the /resources APIs
type ResourcesClient endpoint

// Get corresponds to the GET /resources/:team_label/:resource_label/ endpoint.
//
// Get information about a resource from it's label
// Get information about the resource and it's operational status. The resource will be fetched from
// the list of resources owned by the team.
func (c *ResourcesClient) Get(ctx context.Context, teamLabel string, resourceLabel string, opts *ResourcesGetOpts) (*Resource, error) {
	p := fmt.Sprintf("/resources/%s/%s/", teamLabel, resourceLabel)

	var q url.Values
	if opts != nil {
		q = make(url.Values)
		if opts.ProductLabel != nil {
			q.Set("product_label", *opts.ProductLabel)
		}

		if opts.ProjectLabel != nil {
			q.Set("project_label", *opts.ProjectLabel)
		}
	}

	req, err := c.backend.NewRequest(http.MethodGet, p, q, nil)
	if err != nil {
		return nil, err
	}

	var resp Resource
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// GetMe corresponds to the GET /resources/me/:resource_label/ endpoint.
//
// Get information about a resource from it's label
// Get information about the resource and it's operational status. The resource will be fetched from
// the list of resources owned by the user.
func (c *ResourcesClient) GetMe(ctx context.Context, resourceLabel string, opts *GetMeOpts) (*Resource, error) {
	p := fmt.Sprintf("/resources/me/%s/", resourceLabel)

	var q url.Values
	if opts != nil {
		q = make(url.Values)
		if opts.ProductLabel != nil {
			q.Set("product_label", *opts.ProductLabel)
		}

		if opts.ProjectLabel != nil {
			q.Set("project_label", *opts.ProjectLabel)
		}
	}

	req, err := c.backend.NewRequest(http.MethodGet, p, q, nil)
	if err != nil {
		return nil, err
	}

	var resp Resource
	_, err = c.backend.Do(ctx, req, &resp, func(code int) error {
		switch code {
		case 400, 404, 500:
			return &gomanifold.Error{}
		default:
			return nil
		}
	})
	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// APIClient is an API client for all endpoints.
type APIClient struct {
	common endpoint // Reuse a single struct instead of allocating one for each endpoint on the heap.

	ID        *IDClient
	Product   *ProductClient
	Products  *ProductsClient
	Resource  *ResourceClient
	Resources *ResourcesClient
}

// NewAPI returns a new APIClient with the default configuration.
func NewAPI() *APIClient {
	c := &APIClient{}
	c.common.backend = DefaultBackend()

	c.ID = (*IDClient)(&c.common)
	c.Product = (*ProductClient)(&c.common)
	c.Products = (*ProductsClient)(&c.common)
	c.Resource = (*ResourceClient)(&c.common)
	c.Resources = (*ResourcesClient)(&c.common)

	return c
}
